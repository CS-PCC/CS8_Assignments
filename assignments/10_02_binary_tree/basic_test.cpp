#include "gtest/gtest.h"
#include <iostream>
#include <iomanip>

//------------------------------------------------------------------------------
//Files we are testing:
#include "../../includes/binary_tree/binary_tree.h"



//------------------------------------------------------------------------------

using namespace std;

//------------------------------------------------------------------------------
//          COPY BASIC_TEST INTO THIS FILE.
//                    AND THEN,
//         DO NOT EDIT THIS FILE ANY FURTHER
//------------------------------------------------------------------------------

template <class Item>
void print_item (Item& data)
{
  cout << "[" << data << "]";
}

bool basic_test_tree_node(bool debug=false)
{
  binary_tree_node<int> *root;
  binary_tree_node<int> *child1;
  binary_tree_node<int> *child2;

  const int node1 = 1;
  const int node2 = 2;
  const int node3 = 3;
  const int node4 = 4;
  const int node5 = 5;
  const int node6 = 6;
  const int node7 = 7;

  // create root node
  root = new binary_tree_node<int> (node1);
  
  child1 = new binary_tree_node<int> (node2);
  child2 = new binary_tree_node<int> (node5);

  child2->set_left(new binary_tree_node<int> (node6));
  child2->set_right(new binary_tree_node<int> (node7));

  child1->set_left(new binary_tree_node<int> (node4));
  child1->set_right(child2);

  root->set_left(child1);
  root->set_right(new binary_tree_node<int> (node3));

  cout << "Tree is:" << endl;
  print(root);
  cout << "----------------------------" << endl << endl;

  cout << "Tree debug: [node:height (balance factor)]" << endl;
  print_debug(root);
  cout << "----------------------------" << endl << endl;

  cout << "Left Subtree of root is:" << endl;
  print(root->left());
  cout << "----------------------------" << endl << endl;

  cout << "Right Subtree of root is:" << endl;
  print(root->right());
  cout << "----------------------------" << endl << endl;

  cout << "Root is:" << *root << endl; 
  cout << "Root is: " << root->data() << endl << endl;

  cout << "Balance factor of root: " << root->balance_factor() << endl;
  cout << "Balance factor of left subtree of root: " << root->left()->balance_factor() << endl;
  cout << "Balance factor of right subtree of root: " << root->right()->balance_factor() << endl << endl;

  cout << "Height of root: " << root->height() << endl;
  cout << "Height of left subtree of root: " << root->left()->height() << endl;
  cout << "Height of right subtree of root: " << root->right()->height() << endl << endl;

  cout << "Root is leaf? " << boolalpha << root->is_leaf() << endl;
  cout << "Left subtree of root is leaf? " << boolalpha << root->left()->is_leaf() << endl;
  cout << "Left of left subtree of root is leaf? " << boolalpha << root->left()->left()->is_leaf() << endl;
  cout << "Right subtree of root is leaf? " << boolalpha << root->right()->is_leaf() << endl << endl;
  
  return true;
}

bool basic_test_tree_function(bool debug=false)
{
  binary_tree_node<int> *root;
  binary_tree_node<int> *child1;
  binary_tree_node<int> *child2;

  const int node1 = 1;
  const int node2 = 2;
  const int node3 = 3;
  const int node4 = 4;
  const int node5 = 5;
  const int node6 = 6;
  const int node7 = 7;

  // create root node
  root = new binary_tree_node<int> (node1);
  
  child1 = new binary_tree_node<int> (node2);
  child2 = new binary_tree_node<int> (node5);

  child2->set_left(new binary_tree_node<int> (node6));
  child2->set_right(new binary_tree_node<int> (node7));

  child1->set_left(new binary_tree_node<int> (node4));
  child1->set_right(child2);

  root->set_left(child1);
  root->set_right(new binary_tree_node<int> (node3));

  cout << "Tree is:" << endl;
  print(root);
  cout << "----------------------------" << endl << endl;

  cout << "Tree size    : " << tree_size(root) << endl;

  cout << "pre_order    : ";
  preorder(print_item<int>, root);
  cout << endl;

  cout << "in_order     : ";
  inorder(print_item<int>, root);
  cout << endl;

  cout << "post_order   : ";
  postorder(print_item<int>, root);
  cout << endl;

  binary_tree_node<int> *root_copy;
  cout << "\nMaking a copy of the tree: " << endl;
  root_copy = tree_copy(root);
  cout << "Here is your copy: " << endl;
  print(root_copy);

  cout << "\nClearing the copy tree" << endl;
  tree_clear(root_copy);
  cout << "Tree is cleared? " << boolalpha << (root_copy==nullptr) << endl;
  
  cout << endl;

  return true;
}

//Lord help me! 
const bool debug = false;

TEST(BASIC_TEST, TestTreeNode)
{
  bool success = basic_test_tree_node(debug);
  EXPECT_EQ(success, true);
}

TEST(BASIC_TEST, TestTreeFunction)
{
  bool success = basic_test_tree_function(debug);
  EXPECT_EQ(success, true);
}


int main(int argc, char **argv)
{
  ::testing::InitGoogleTest(&argc, argv);
  std::cout<<"\n\n----------running basic_test.cpp---------\n\n"<<std::endl;
  return RUN_ALL_TESTS();
}


/*
includes
└── binary_tree
    └── binary_tree.h

1 directory, 1 file

----------running basic_test.cpp---------


[==========] Running 2 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 2 tests from BASIC_TEST
[ RUN      ] BASIC_TEST.TestTreeNode
Tree is:
    [3]
[1]
            [7]
        [5]
            [6]
    [2]
        [4]
----------------------------

Tree debug: [node:height (balance factor)]
    [3:0 (0)]
[1:3 (2)]
            [7:0 (0)]
        [5:1 (0)]
            [6:0 (0)]
    [2:2 (-1)]
        [4:0 (0)]
----------------------------

Left Subtree of root is:
        [7]
    [5]
        [6]
[2]
    [4]
----------------------------

Right Subtree of root is:
[3]
----------------------------

Root is:[1]
Root is: 1

Balance factor of root: 2
Balance factor of left subtree of root: -1
Balance factor of right subtree of root: 0

Height of root: 3
Height of left subtree of root: 2
Height of right subtree of root: 0

Root is leaf? false
Left subtree of root is leaf? false
Left of left subtree of root is leaf? true
Right subtree of root is leaf? true

[       OK ] BASIC_TEST.TestTreeNode (0 ms)
[ RUN      ] BASIC_TEST.TestTreeFunction
Tree is:
    [3]
[1]
            [7]
        [5]
            [6]
    [2]
        [4]
----------------------------

Tree size    : 7
pre_order    : [1][2][4][5][6][7][3]
in_order     : [4][2][6][5][7][1][3]
post_order   : [4][6][7][5][2][3][1]

Making a copy of the tree: 
Here is your copy: 
    [3]
[1]
            [7]
        [5]
            [6]
    [2]
        [4]

Clearing the copy tree
Tree is cleared? true

[       OK ] BASIC_TEST.TestTreeFunction (0 ms)
[----------] 2 tests from BASIC_TEST (0 ms total)

[----------] Global test environment tear-down
[==========] 2 tests from 1 test suite ran. (0 ms total)
[  PASSED  ] 2 tests.
*/